<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Orchestra Layout Designer</title>
    <style>
        :root {
            --bg-color: #1a1a1a;
            --panel-bg: #2a2a2a;
            --text-color: #e0e0e0;
            --accent: #00d2ff;
            --border: #444;
            --grid-line: #333;
            --select-box: rgba(0, 210, 255, 0.2);
        }
        body { margin: 0; background: var(--bg-color); color: var(--text-color); font-family: 'Segoe UI', sans-serif; display: flex; height: 100vh; overflow: hidden; user-select: none; }
        
        /* Sidebar Tools */
        .sidebar { 
            width: 320px; /* Widened for more data fields */
            background: var(--panel-bg); 
            border-right: 1px solid var(--border); 
            display: flex; flex-direction: column; 
            padding: 15px; box-sizing: border-box; 
            z-index: 20; 
            overflow-y: auto;
        }
        .sidebar h3 { margin-top: 0; color: var(--accent); border-bottom: 1px solid var(--border); padding-bottom: 10px; font-size: 1.1em; }
        
        button {
            background: #333; color: white; border: 1px solid #555; padding: 10px; margin-bottom: 8px; cursor: pointer; text-align: left; transition: all 0.2s; border-radius: 4px;
        }
        button:hover { background: #444; }
        button.active { background: var(--accent); color: #000; font-weight: bold; border-color: var(--accent); }
        
        .control-group { margin-bottom: 20px; display: flex; flex-direction: column; }
        label { font-size: 0.8em; color: #888; margin-bottom: 4px; font-weight: 600; }
        input, select, textarea { 
            background: #111; border: 1px solid #444; color: white; padding: 8px; margin-bottom: 10px; 
            border-radius: 4px; font-family: inherit; font-size: 0.9em;
        }
        input:focus, select:focus, textarea:focus { border-color: var(--accent); outline: none; }
        textarea { resize: vertical; min-height: 60px; }
        
        .hint { font-size: 0.75em; color: #666; margin-top: -8px; margin-bottom: 10px; font-style: italic; }
        .row { display: flex; gap: 10px; }
        .row > div { flex: 1; }

        /* Main Canvas Area */
        #canvas-area { flex: 1; position: relative; overflow: hidden; background: #151515; cursor: default; }
        
        svg { width: 100%; height: 100%; outline: none; display: block; }
        
        /* Zoom Controls */
        #zoom-controls {
            position: absolute; bottom: 20px; right: 20px; display: flex; gap: 5px; z-index: 100;
        }
        .zoom-btn { width: 30px; height: 30px; text-align: center; padding: 0; font-weight: bold; font-size: 1.2em; border-radius: 50%; box-shadow: 0 4px 8px rgba(0,0,0,0.5); }

        /* Grid */
        .grid-line { stroke: var(--grid-line); stroke-width: 1; }
        
        /* SVG Elements */
        .poly-draft { fill: none; stroke: var(--accent); stroke-width: 2; stroke-dasharray: 5,5; vector-effect: non-scaling-stroke; }
        .poly-finished { stroke-width: 2; transition: opacity 0.2s; cursor: pointer; vector-effect: non-scaling-stroke; }
        .poly-finished:hover { opacity: 0.8; }
        .poly-selected { stroke: #fff !important; stroke-dasharray: 8,4; stroke-width: 3; }
        
        .player-node { stroke: #fff; stroke-width: 1; transition: r 0.1s; cursor: pointer; vector-effect: non-scaling-stroke; }
        .player-node:hover { stroke-width: 2; }
        .player-selected { stroke: var(--accent); stroke-width: 3; fill: #fff !important; }

        .selection-rect { fill: var(--select-box); stroke: var(--accent); stroke-width: 1; pointer-events: none; vector-effect: non-scaling-stroke; }

        /* Hidden/Visible Helpers */
        .hidden { display: none !important; }

        /* JSON Modals */
        #output-modal, #import-modal {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8); display: none; justify-content: center; align-items: center; z-index: 200;
        }
        .modal-content {
            background: var(--panel-bg); padding: 20px; width: 600px; height: 500px; display: flex; flex-direction: column; border-radius: 8px; border: 1px solid var(--accent);
        }
        .modal-textarea { flex: 1; background: #111; color: #0f0; font-family: monospace; border: 1px solid #444; padding: 10px; resize: none; }
        .modal-actions { margin-top: 10px; display: flex; justify-content: flex-end; gap: 10px; }

    </style>
</head>
<body>

    <!-- LEFT SIDEBAR: Tools -->
    <div class="sidebar">
        <h3>Toolbox</h3>
        <div class="control-group">
            <button id="btn-select" class="active" onclick="setMode('select')">üëÜ Select / Move / Drag</button>
            <button id="btn-poly" onclick="setMode('draw_poly')">‚¨† Draw Section</button>
            <button id="btn-player" onclick="setMode('add_player')">‚óè Add Player</button>
            <button id="btn-delete" onclick="deleteSelected()" style="background: #522; border-color: #844;">üóë Delete Selected</button>
        </div>

        <div class="control-group">
            <label>Grid Snapping (px)</label>
            <input type="number" id="grid-size" value="20" min="5" max="100" onchange="updateGrid()">
            <div class="hint">Hold Space + Drag to Pan</div>
        </div>

        <h3>Properties</h3>
        <div id="props-panel">
            <p id="no-selection-msg" style="color: #666; font-style: italic;">Select an item to edit...</p>
            
            <div id="props-form" class="hidden">
                <div class="control-group">
                    <label>Section Assignment / ID</label>
                    <input type="text" id="prop-id" placeholder="ID or Section ID">
                    
                    <label>Display Name</label>
                    <input type="text" id="prop-name" placeholder="Name">

                    <!-- Player Specific Fields -->
                    <div id="player-fields" class="hidden">
                        <div class="row">
                            <div>
                                <label>Age</label>
                                <input type="number" id="prop-age" min="0">
                            </div>
                            <div>
                                <label>Status</label>
                                <select id="prop-status">
                                    <option value="true">Alive</option>
                                    <option value="false">Deceased</option>
                                </select>
                            </div>
                        </div>
                        
                        <label>Symptomatic</label>
                        <select id="prop-symptomatic">
                            <option value="false">No</option>
                            <option value="true">Yes</option>
                        </select>

                        <label>Medical History</label>
                        <textarea id="prop-history" placeholder="Enter history..."></textarea>
                    </div>

                    <label>Color</label>
                    <input type="color" id="prop-color" value="#4facfe">
                    <div class="hint">Section Color OR Player Override</div>
                </div>
            </div>
        </div>

        <div style="margin-top: auto;">
            <button onclick="openImportModal()" style="background: #444; color: #fff; font-weight: bold; width: 100%; margin-bottom: 10px;">IMPORT JSON</button>
            <button onclick="exportData()" style="background: var(--accent); color: #000; font-weight: bold; width: 100%;">EXPORT JSON</button>
        </div>
    </div>

    <!-- MAIN CANVAS -->
    <div id="canvas-area">
        <svg id="stage">
            <defs>
                <pattern id="grid" width="20" height="20" patternUnits="userSpaceOnUse">
                    <path d="M 20 0 L 0 0 0 20" fill="none" stroke="#222" stroke-width="1"/>
                </pattern>
            </defs>
            <!-- Viewport Group for Zoom/Pan -->
            <g id="viewport">
                <rect id="bg-rect" x="-5000" y="-5000" width="10000" height="10000" fill="url(#grid)" />
                <g id="layer-polys"></g>
                <g id="layer-draft"></g>
                <g id="layer-players"></g>
                <g id="layer-ui"></g> <!-- Selection Box -->
            </g>
        </svg>

        <div id="zoom-controls">
            <button class="zoom-btn" onclick="applyZoom(1.2)" title="Zoom In">+</button>
            <button class="zoom-btn" onclick="applyZoom(0.8)" title="Zoom Out">-</button>
            <button class="zoom-btn" onclick="resetZoom()" title="Reset View" style="font-size: 0.8em">R</button>
        </div>
    </div>

    <!-- JSON OUTPUT MODAL -->
    <div id="output-modal">
        <div class="modal-content">
            <h3 style="margin-top:0">Export Data</h3>
            <p style="font-size:0.9em; color:#888;">Copy this into <code>orchestra_data.json</code></p>
            <textarea id="json-output" class="modal-textarea"></textarea>
            <div class="modal-actions">
                <button onclick="document.getElementById('output-modal').style.display='none'">Close</button>
                <button onclick="copyToClipboard()" style="background:var(--accent); color:black;">Copy</button>
            </div>
        </div>
    </div>

    <!-- JSON IMPORT MODAL -->
    <div id="import-modal">
        <div class="modal-content">
            <h3 style="margin-top:0">Import Data</h3>
            <p style="font-size:0.9em; color:#888;">Paste <code>orchestra_data.json</code> content here to load it.</p>
            <textarea id="json-input" class="modal-textarea"></textarea>
            <div class="modal-actions">
                <button onclick="document.getElementById('import-modal').style.display='none'">Cancel</button>
                <button onclick="importData()" style="background:var(--accent); color:black;">Load Data</button>
            </div>
        </div>
    </div>

<script>
    // --- STATE ---
    let mode = 'select'; 
    let gridSize = 20;
    
    let sections = [];
    let players = [];
    
    // Selection
    let selection = [];
    
    // Draft
    let draftPoints = [];

    // Dragging
    let isDragging = false;
    let dragStart = { x: 0, y: 0 };
    let snapshot = [];

    // Box Select
    let isBoxSelecting = false;
    let boxStart = { x: 0, y: 0 };

    // Pan & Zoom
    let viewX = 0;
    let viewY = 0;
    let viewScale = 1;
    let isPanning = false;
    let panStart = { x: 0, y: 0 };

    // DOM Elements
    const svg = document.getElementById('stage');
    const viewport = document.getElementById('viewport');
    const layerPolys = document.getElementById('layer-polys');
    const layerPlayers = document.getElementById('layer-players');
    const layerDraft = document.getElementById('layer-draft');
    const layerUI = document.getElementById('layer-ui');
    
    // Inputs
    const propsForm = document.getElementById('props-form');
    const noSelectMsg = document.getElementById('no-selection-msg');
    const inputs = {
        id: document.getElementById('prop-id'),
        name: document.getElementById('prop-name'),
        color: document.getElementById('prop-color'),
        age: document.getElementById('prop-age'),
        status: document.getElementById('prop-status'),
        symptomatic: document.getElementById('prop-symptomatic'),
        history: document.getElementById('prop-history'),
        playerFields: document.getElementById('player-fields')
    };

    // --- INITIALIZATION ---
    updateGrid();
    setupEventHandlers();
    setupAutoUpdate();

    // --- TRANSFORM & COORDS ---
    function updateTransform() {
        viewport.setAttribute('transform', `translate(${viewX}, ${viewY}) scale(${viewScale})`);
    }

    function applyZoom(factor) {
        viewScale *= factor;
        updateTransform();
    }

    function resetZoom() {
        viewX = 0; viewY = 0; viewScale = 1;
        updateTransform();
    }

    function getMousePos(evt) {
        // Convert screen coordinates to SVG Local coordinates inside the viewport group
        // Formula: (Screen - Translate) / Scale
        const CTM = svg.getScreenCTM();
        const screenX = evt.clientX;
        const screenY = evt.clientY;

        // Raw SVG coord (ignoring viewBox if we had one, but we use group transform)
        // Adjust for SVG position on screen
        const relX = screenX - CTM.e;
        const relY = screenY - CTM.f;

        // Apply Viewport Transform inverse
        const localX = (relX - viewX) / viewScale;
        const localY = (relY - viewY) / viewScale;

        return { 
            x: localX, 
            y: localY, 
            snappedX: snap(localX), 
            snappedY: snap(localY) 
        };
    }

    function snap(val) {
        return Math.round(val / gridSize) * gridSize;
    }

    // --- EVENT HANDLERS ---
    function setupEventHandlers() {
        svg.addEventListener('mousedown', onMouseDown);
        window.addEventListener('mousemove', onMouseMove);
        window.addEventListener('mouseup', onMouseUp);
        
        // Wheel Zoom
        svg.addEventListener('wheel', (e) => {
            e.preventDefault();
            const factor = e.deltaY > 0 ? 0.9 : 1.1;
            viewScale *= factor;
            updateTransform();
        });
    }

    function setupAutoUpdate() {
        // Attach oninput listener to all inputs for auto-update
        const inputList = [inputs.id, inputs.name, inputs.color, inputs.age, inputs.status, inputs.symptomatic, inputs.history];
        inputList.forEach(el => {
            el.oninput = applyPropChange;
        });
    }

    function onMouseDown(evt) {
        // Check for Pan (Spacebar or Middle Click)
        if (evt.button === 1 || (evt.button === 0 && evt.code === 'Space')) {
            isPanning = true;
            panStart = { x: evt.clientX, y: evt.clientY };
            return;
        }

        const pos = getMousePos(evt);
        const target = evt.target;
        const isShift = evt.shiftKey;

        // Mode: Draw Polygon
        if (mode === 'draw_poly') {
            handlePolyDrawClick(pos);
            return;
        }

        // Mode: Add Player
        if (mode === 'add_player') {
            addPlayer(pos.snappedX, pos.snappedY);
            return;
        }

        // Mode: Select
        if (mode === 'select') {
            const hitType = target.getAttribute('data-type');
            const hitIndex = parseInt(target.getAttribute('data-index'));

            if (hitType) {
                // Clicked object
                const alreadySelected = selection.find(s => s.type === hitType && s.index === hitIndex);
                if (isShift) {
                    if (alreadySelected) {
                        selection = selection.filter(s => !(s.type === hitType && s.index === hitIndex));
                    } else {
                        selection.push({ type: hitType, index: hitIndex });
                    }
                } else {
                    if (!alreadySelected) {
                        selection = [{ type: hitType, index: hitIndex }];
                    }
                }
                startDrag(pos);
                renderScene(); // To update selection visuals
                populateProps();
            } else {
                // Clicked Empty Space
                if (!isShift) {
                    selection = [];
                    populateProps();
                }
                startBoxSelect(pos);
                renderScene();
            }
        }
    }

    function onMouseMove(evt) {
        if (isPanning) {
            const dx = evt.clientX - panStart.x;
            const dy = evt.clientY - panStart.y;
            viewX += dx;
            viewY += dy;
            panStart = { x: evt.clientX, y: evt.clientY };
            updateTransform();
            return;
        }

        const pos = getMousePos(evt);

        if (mode === 'draw_poly') renderDraft(pos);
        else if (isDragging) handleDrag(pos);
        else if (isBoxSelecting) handleBoxSelect(pos);
    }

    function onMouseUp(evt) {
        isPanning = false;
        isDragging = false;
        if (isBoxSelecting) finishBoxSelect();
    }

    // --- TOOLBAR FUNCTIONS ---
    function setMode(newMode) {
        mode = newMode;
        document.querySelectorAll('.sidebar button').forEach(b => b.classList.remove('active'));
        if(newMode === 'select') document.getElementById('btn-select').classList.add('active');
        if(newMode === 'draw_poly') document.getElementById('btn-poly').classList.add('active');
        if(newMode === 'add_player') document.getElementById('btn-player').classList.add('active');

        draftPoints = [];
        renderDraft();
        selection = [];
        renderScene();
        populateProps();
    }

    function updateGrid() {
        gridSize = parseInt(document.getElementById('grid-size').value) || 20;
        const pattern = document.getElementById('grid');
        pattern.setAttribute('width', gridSize);
        pattern.setAttribute('height', gridSize);
        pattern.innerHTML = `<path d="M ${gridSize} 0 L 0 0 0 ${gridSize}" fill="none" stroke="#2a2a2a" stroke-width="1"/>`;
    }

    // --- LOGIC ---
    function addPlayer(x, y) {
        let assignedSection = sections.length > 0 ? sections[sections.length - 1].id : "section_1";
        players.push({
            id: players.length + 1,
            section_id: assignedSection,
            x: x, y: y,
            name: `Player ${players.length + 1}`,
            age: 30, alive: true, symptomatic: false, history: "None"
        });
        renderScene();
    }

    function finishPoly() {
        if (draftPoints.length < 3) return;
        const pointsStr = draftPoints.map(p => `${p.x},${p.y}`).join(' ');
        const id = `section_${sections.length + 1}`;
        sections.push({
            id: id,
            name: "New Section",
            color: inputs.color.value,
            polygon_points: pointsStr,
            label_pos: getCentroid(draftPoints)
        });
        draftPoints = [];
        renderDraft();
        renderScene();
        setMode('select');
    }

    function handlePolyDrawClick(pos) {
        if (draftPoints.length > 2) {
            const start = draftPoints[0];
            const dx = Math.abs(pos.snappedX - start.x);
            const dy = Math.abs(pos.snappedY - start.y);
            if (dx < gridSize/2 && dy < gridSize/2) {
                finishPoly();
                return;
            }
        }
        draftPoints.push({ x: pos.snappedX, y: pos.snappedY });
        renderDraft();
    }

    function renderDraft(mousePos = null) {
        layerDraft.innerHTML = '';
        if (draftPoints.length === 0) return;
        let d = `M ${draftPoints[0].x} ${draftPoints[0].y}`;
        for (let i = 1; i < draftPoints.length; i++) {
            d += ` L ${draftPoints[i].x} ${draftPoints[i].y}`;
        }
        if (mousePos) d += ` L ${mousePos.snappedX} ${mousePos.snappedY}`;
        
        const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
        path.setAttribute("d", d);
        path.setAttribute("class", "poly-draft");
        layerDraft.appendChild(path);
    }

    // --- DRAG ---
    function startDrag(pos) {
        isDragging = true;
        dragStart = { x: pos.snappedX, y: pos.snappedY };
        snapshot = selection.map(item => {
            if (item.type === 'player') {
                const p = players[item.index];
                return { type: 'player', index: item.index, x: p.x, y: p.y };
            } else {
                const s = sections[item.index];
                const pts = s.polygon_points.split(' ').map(pair => {
                    const [px, py] = pair.split(',').map(Number);
                    return { x: px, y: py };
                });
                const lbl = s.label_pos ? { ...s.label_pos } : null;
                return { type: 'section', index: item.index, points: pts, label_pos: lbl };
            }
        });
    }

    function handleDrag(pos) {
        if (!isDragging) return;
        const dx = pos.snappedX - dragStart.x;
        const dy = pos.snappedY - dragStart.y;

        snapshot.forEach(snapItem => {
            if (snapItem.type === 'player') {
                const p = players[snapItem.index];
                p.x = snapItem.x + dx;
                p.y = snapItem.y + dy;
            } else {
                const s = sections[snapItem.index];
                s.polygon_points = snapItem.points.map(pt => `${pt.x + dx},${pt.y + dy}`).join(' ');
                if (snapItem.label_pos) {
                    s.label_pos = { x: snapItem.label_pos.x + dx, y: snapItem.label_pos.y + dy };
                }
            }
        });
        renderScene();
    }

    // --- BOX SELECT ---
    function startBoxSelect(pos) {
        isBoxSelecting = true;
        boxStart = { x: pos.x, y: pos.y };
        drawSelectionBox(boxStart.x, boxStart.y, 0, 0);
    }

    function handleBoxSelect(pos) {
        if (!isBoxSelecting) return;
        const x = Math.min(boxStart.x, pos.x);
        const y = Math.min(boxStart.y, pos.y);
        const w = Math.abs(pos.x - boxStart.x);
        const h = Math.abs(pos.y - boxStart.y);
        drawSelectionBox(x, y, w, h);
    }

    function finishBoxSelect() {
        isBoxSelecting = false;
        const rect = document.getElementById('selection-rect');
        if (!rect) return;
        const rx = parseFloat(rect.getAttribute('x'));
        const ry = parseFloat(rect.getAttribute('y'));
        const rw = parseFloat(rect.getAttribute('width'));
        const rh = parseFloat(rect.getAttribute('height'));
        layerUI.innerHTML = ''; 

        // Check intersections
        players.forEach((p, idx) => {
            if (p.x >= rx && p.x <= rx + rw && p.y >= ry && p.y <= ry + rh) {
                if (!selection.find(s => s.type === 'player' && s.index === idx)) {
                    selection.push({ type: 'player', index: idx });
                }
            }
        });

        // Simple bounding box check for polys for simplicity
        sections.forEach((s, idx) => {
            const points = s.polygon_points.split(' ').map(pair => {
                const [px, py] = pair.split(',').map(Number);
                return { x: px, y: py };
            });
            const isInside = points.some(p => p.x >= rx && p.x <= rx + rw && p.y >= ry && p.y <= ry + rh);
            if (isInside) {
                if (!selection.find(s => s.type === 'section' && s.index === idx)) {
                    selection.push({ type: 'section', index: idx });
                }
            }
        });
        renderScene();
        populateProps();
    }

    function drawSelectionBox(x, y, w, h) {
        layerUI.innerHTML = '';
        const r = document.createElementNS("http://www.w3.org/2000/svg", "rect");
        r.setAttribute("id", "selection-rect");
        r.setAttribute("x", x); r.setAttribute("y", y); r.setAttribute("width", w); r.setAttribute("height", h);
        r.setAttribute("class", "selection-rect");
        layerUI.appendChild(r);
    }

    // --- RENDER SCENE ---
    function renderScene() {
        layerPolys.innerHTML = '';
        layerPlayers.innerHTML = '';

        sections.forEach((sect, index) => {
            const isSelected = selection.some(s => s.type === 'section' && s.index === index);
            const poly = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
            poly.setAttribute("points", sect.polygon_points);
            poly.setAttribute("fill", sect.color);
            poly.setAttribute("fill-opacity", "0.2");
            poly.setAttribute("stroke", sect.color);
            poly.setAttribute("class", "poly-finished" + (isSelected ? " poly-selected" : ""));
            poly.setAttribute("data-type", "section");
            poly.setAttribute("data-index", index);
            layerPolys.appendChild(poly);
            
            if (sect.label_pos) {
                const txt = document.createElementNS("http://www.w3.org/2000/svg", "text");
                txt.setAttribute("x", sect.label_pos.x);
                txt.setAttribute("y", sect.label_pos.y);
                txt.setAttribute("fill", "white");
                txt.setAttribute("font-size", "10");
                txt.setAttribute("text-anchor", "middle");
                txt.setAttribute("pointer-events", "none");
                txt.textContent = sect.name;
                layerPolys.appendChild(txt);
            }
        });

        players.forEach((p, index) => {
            const isSelected = selection.some(s => s.type === 'player' && s.index === index);
            const parentSect = sections.find(s => s.id === p.section_id);
            const color = p.custom_color ? p.custom_color : (parentSect ? parentSect.color : '#888');
            const c = document.createElementNS("http://www.w3.org/2000/svg", "circle");
            c.setAttribute("cx", p.x); c.setAttribute("cy", p.y); c.setAttribute("r", 6);
            c.setAttribute("class", "player-node" + (isSelected ? " player-selected" : ""));
            c.setAttribute("fill", color);
            c.setAttribute("data-type", "player");
            c.setAttribute("data-index", index);
            layerPlayers.appendChild(c);
        });
    }

    // --- PROPERTIES & AUTO UPDATE ---
    function populateProps() {
        if (selection.length === 0) {
            propsForm.classList.add('hidden');
            noSelectMsg.classList.remove('hidden');
            return;
        }

        propsForm.classList.remove('hidden');
        noSelectMsg.classList.add('hidden');

        const first = selection[0];
        const isPlayer = first.type === 'player';

        if (isPlayer) {
            const p = players[first.index];
            inputs.id.value = p.section_id;
            inputs.name.value = p.name;
            inputs.color.value = p.custom_color || "#ffffff";
            
            // New Fields
            inputs.age.value = p.age || 0;
            inputs.status.value = p.alive.toString();
            inputs.symptomatic.value = p.symptomatic.toString();
            inputs.history.value = p.history || "";

            inputs.playerFields.classList.remove('hidden');
        } else {
            const s = sections[first.index];
            inputs.id.value = s.id;
            inputs.name.value = s.name;
            inputs.color.value = s.color;

            inputs.playerFields.classList.add('hidden');
        }
    }

    function applyPropChange() {
        selection.forEach(item => {
            if (item.type === 'player') {
                const p = players[item.index];
                if(inputs.id.value) p.section_id = inputs.id.value;
                if(inputs.name.value && selection.length === 1) p.name = inputs.name.value;
                p.custom_color = inputs.color.value;
                
                // New Fields
                p.age = parseInt(inputs.age.value) || 0;
                p.alive = inputs.status.value === 'true';
                p.symptomatic = inputs.symptomatic.value === 'true';
                p.history = inputs.history.value;

            } else {
                const s = sections[item.index];
                if(inputs.id.value) s.id = inputs.id.value;
                if(inputs.name.value) s.name = inputs.name.value;
                if(inputs.color.value) s.color = inputs.color.value;
            }
        });
        renderScene();
    }

    function deleteSelected() {
        // Sort descending to delete cleanly
        const pIdx = selection.filter(s => s.type === 'player').map(s => s.index).sort((a,b)=>b-a);
        const sIdx = selection.filter(s => s.type === 'section').map(s => s.index).sort((a,b)=>b-a);
        pIdx.forEach(i => players.splice(i,1));
        sIdx.forEach(i => sections.splice(i,1));
        selection = [];
        renderScene();
        populateProps();
    }

    // --- HELPERS ---
    function getCentroid(points) {
        let x = 0, y = 0;
        points.forEach(p => { x += p.x; y += p.y; });
        return { x: Math.round(x/points.length), y: Math.round(y/points.length) };
    }

    // --- EXPORT/IMPORT ---
    function exportData() {
        const out = {
            config: { hover_metrics: ["total_count", "percent_deceased", "percent_symptomatic"] },
            sections: sections,
            players: players
        };
        document.getElementById('json-output').value = JSON.stringify(out, null, 2);
        document.getElementById('output-modal').style.display = 'flex';
    }
    function copyToClipboard() {
        document.getElementById("json-output").select();
        document.execCommand("copy");
        alert("Copied!");
    }
    function openImportModal() {
        document.getElementById('json-input').value = '';
        document.getElementById('import-modal').style.display = 'flex';
    }
    function importData() {
        try {
            const d = JSON.parse(document.getElementById('json-input').value);
            if(!d.sections || !d.players) throw new Error("Invalid Format");
            sections = d.sections;
            players = d.players;
            selection = [];
            renderScene();
            document.getElementById('import-modal').style.display = 'none';
        } catch(e) { alert("Error: " + e.message); }
    }

</script>
</body>
</html>